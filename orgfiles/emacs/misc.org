#+TAGS: tech
** 設定ファイルを分割する方法

最も簡単な方法は load 関数を使って下のように読み込む。拡張子は省略しても良い。
ちょっと作ってみた関数とかは適当な名前をつけて隔離しておき下のようにして読み込めばいい。

#+begin_src lisp
(load "~/my-lisp/hogehoge.el")
#+end_src

より高機能な方法として require を使う方法がある。

#+begin_src
(require hoge-feature)
#+end_src

require の引数には feature と呼ばれるものを与える。
feature とは読み込もうとしているパッケージの名前で、パスではない。
feature に与えられる名前を持つには (provide) によりパッケージ名を定めなければならない。
自分で feature を作るには次のようなファイルを作る。

#+begin_src lisp
(provide 'hoge-feature)
(message "hoge-feature is loaded")
#+end_src

この feature はメッセージを出力するだけの feature である。
このファイルを ~/my-lisp/hoge-feature.el として保存してみよう。
最後に下記のプログラムを実行すれば ~/my-lisp/hoge-feature.el が読み込まれる。

#+begin_src lisp
(add-to-list 'load-path "~/my-lisp/")
(require hoge-feature)
#+end_src

変数 load-path は feature の探索範囲を示すリストで、このリストに ~/my-lisp/ を加えることでそこにあるファイルを見つけることができる。

require を使えば2重に読み込んでしまうことを避けられるので、
いろいろなパッケージから参照されているようなパッケージは require を使って読み込むべきである。
ただし、自分だけの設定ファイルなどはよそから参照されることはないので、普段遣いは load で十分だろう。

** ラムダ（匿名関数）

フックを使って emacs をカスタマイズするとき、引数に関数あたえなければならない。
しかしわざわざ関数に名前をつけるのが面倒なときには、ラムダを使って名前のない関数を作ることができる。

#+begin_src lisp
(lambda () (message "hello"))
#+end_src

ラムダ関数の第一引数は引数のリストで、それ以降が本体である。
ラムダを評価するには関数 funcall を使う。

#+begin_src lisp
(setq my-lambda (lambda () (message "hello")))
(funcall my-lambda)
#+end_src

引数がある場合は下のようにする。

#+begin_src
(setq my-lambda (lambda (a b) (message (concat a b))))
(funcall my-lambda "hoge" "fuga")
#+end_src

** ローカル変数(let)
特殊形式 (let VARLIST BODY...) で表現する。

- VARLIST は1つ以上の (変数名 値) からなるリスト
- BODY は1つ以上の式

もっともかんたんな使い方は下のようになる。

#+begin_src lisp
(let ((a "hello")) (message a))
#+end_src

変数名のリストをあたえてもよい。
その場合は nil がセットされるので、あとから値をセットする。

#+begin_src lisp
(let (a b)
  (setq a "hello")
  (setq b "goodbye")
  (message (concat a b)))
#+end_src

let は BODY で最後に評価した式の値を返す。

アスタリスク付きの let* も存在する。
let* は変数の初期化を VARLIST で列挙された順に一つずつ行う。
下のプログラムは let* だけが実行でき let は実行できない。

#+begin_src lisp
(let* ((a "hello") (z a)) (message z))
#+end_src

** プロパタイズ(propertize)

(propertize STRING &rest PROPERTIES)

- STRING はコピー対象の文字列
- PROPERTIES は PROPERTY VALUE のペア列

評価結果はプロパティを持つオブジェクトになる。
関数 get-text-property を使ってオブジェクトのプロパティを取り出すことができる。

#+begin_src lisp
(let ((x (propertize "john" :age 20 :height 170)))
  (print (get-text-property 0 :age x))
  (print (get-text-property 0 :height x)))
#+end_src

プロパティにラムダをセットすることもできるようだ。

** フォントフェイス

フェイスは文字を装飾するためのオブジェクト。代表的な属性としては下記のものがある。

- font(フォント)
- height(高さ)
- weight(太さ)
- slant(傾き)
- foreground(前景)
- background(背景)
- underline(アンダーライン)
- overline(オーバーライン)
- inherit(継承元)

定義済みのフェイス一覧を見るには、list-faces-display を実行する。特定のフェイスの属性を確認したい場合は describe-face を実行する。

ほとんどのモードはマイナーモードとして font-lock-mode を伴っており自動的に font-lock-mode が有効になる。すると、そのバッファのテキストには特定のフェイスが割り当てられるようになる。

https://ayatakesi.github.io/emacs/27.1/emacs-ja.html#Faces

** フック(hook)

フックは、関数もしくは関数のリストを持っている変数のこと。他の言語で言うコールバックのようなもの。たとえばフック ~find-file-not-found-hooks~ は、ファイルを探しても見つからなかったときに呼び出される関数（のリスト）である。フックは引数なしで呼び出される。

変数名が ~-hook(s)~ で終わらないフックも存在する。それはアブノーマルフックと呼ばれる。通常のフックは引数を取らず、戻り値も利用しないが、アブノーマルフックは引数を取ったり、戻り値を利用したりする。

フックに関数を追加するときは `add-hook` を使うべきである。add-hook は、リスト操作の関数よりも高級であり、重複している場合追加しない、といった機能を備えている。

#+begin_src lisp
(add-hook 'ruby-mode-hook 'lsp-mode) ; ruby-mode のフックに lsp-mode を追加する
#+end_src

add-hook は通常は2つの引数で十分だが、第3引数, 第4引数を与えることもできる。第3引数はフックの挿入位置のフラグ。省略した場合は先頭に追加される。先頭に追加された場合は他よりも先に呼び出される（が基本的には順序依存させないようにするべき）フラグを省略せず t を与えた場合はフックリストの末尾に追加される。第4引数はローカルフックのフラグとなっていて、これが t の場合はバッファローカルなフックとなる。

フックがちゃんと動くかどうか確かめたいときは `run-hook` を使う。たとえば下記のようにすると `org-mode-hook` フックに登録された関数が呼び出される。

#+begin_src lisp
(run-hooks 'org-mode-hook)
#+end_src
** 変数宣言

変数宣言には defconst, defvar がある。これらは特殊形式で下のように振る舞う。

- defconst は常に変数を初期化する。
- defvar は変数が未設定のときだけ初期化する。

defvar がこうなっているのは、ユーザーが事前に setq でカスタムした場合にそれを反映されるため。
defvar, defconst はコメントを書いておくと setq と違って describe-variables で説明を出してくれる。

** コンスセル

コンスセルは2つの任意要素 CAR, CDR の対である。
コンスセルを作るには関数 cons を利用する。

(cons "hello" 2)

上記の関数を評価した値は、 CAR が "hello" であり CDR が 2 のコンスセルである。Emacs の実行環境で試した場合は ("hello" . 2) と表示される。コンスセルは、その要素としてコンスセルを持つことができる。

(cons "boo" (cons "hello" (cons "goodbye" nil)))

上記の関数を評価した値は下記のような構造を持ったコンスセルとなる。

- CAR "boo"
- CDR
  - CAR "hello"
  - CDR
    - CAR "goodbye"
    - CDR nil

これは一般に連結リスト(linked list)と呼ばれるデータ構造をなす。最後の nil はリストが終わりであることを表すマーカで、終端記号と呼ばれる。Emacs の実行環境では ("boo" "hello" "goodbye") と表示される。

つまり、これまでリストと呼んでいたものはコンスセルだとも言える。たとえばリスト ("a" "b" "c") に対してその CAR, CDR を計算すると、それがコンスセルであることがわかる。

(car '("a" "b" "c")) ;; a を返す
(cdr '("a" "b" "c")) ;; ("b" "c") を返す

** 型を調べる

変数 x があるとき (type-of x) でその型を調べることができる。

** 関数へのパッチ(advice-add)

かつては defadvice という関数が使われていたが今では advice-add を使うのが推奨されているようだ。

https://misaki-blog.com/191026-emacs-advice-add/ ここに例がある。

(defun my-find-file (old-func &rest args)
  (print args)
  (apply old-func args))

(advice-add #'find-file :around #'my-find-file)
** 連想リスト(association-list)

連想リストはコンスセルで作られた値のペアを要素として持つリスト。
一番よく見かけるのは auto-mode-alist という変数。例えば下のようになっている。

#+begin_src lisp
((".ruby" . ruby-mode) (".ts" . typescript-mode))
#+end_src

** ディレクトリローカル変数

ディレクトリローカル変数は、emacs がそのディレクトリ、
またはその配下にあるディレクトリを訪問するときだけ有効になる変数。

ディレクトリに .dir-locals.el というファイルを配置して、
対象メジャーモードと、そのモードで有効となるディレクトリローカル変数の連想リストを書く。
すると、ディレクトリローカル変数を定義できる。
下の例はメジャーモードが nil なので全てのメジャーモードを対象にして 2 つの変数を定義している。

#+begin_src
((nil . ((indent-tabs-mode . t) (fill-column . 80))))
#+end_src

次の例は c-mode のときに変数を定義する。ただし (subdir . nil) は実際には変数ではない。
ディレクトリローカル変数がサブディレクトリで無効になるようにする特別なフラグである。

#+begin_src lisp
((c-mode . ((c-file-style . "BSD") (subdirs . nil))))
#+end_src

特定のサブディレクトリに対してディレクトリローカル変数を定義する機能もあるらしい。
（よくわからない）

#+begin_src
(("src/imported" . ((nil . ((change-log-default-name . "ChangeLog.local"))))))
#+end_src

.dir-locals.elファイルを手で編集するかわりに、コマンド M-x add-dir-local-variable を使ってディレクトリローカル変数を作るのも良い。
これはモード名またはサブディレクトリー名、および変数名と値の入力を求め、ディレクトリーローカル変数を定義するエントリーを追加します。
M-x delete-dir-local-variableは、エントリーを削除します。
M-x copy-file-locals-to-dir-localsは、カレントファイル内のファイルローカル変数を、.dir-locals.elにコピーします。

他にもディレクトリローカル変数を与える方法が有るらしいけどいったんこれくらいで。

https://ayatakesi.github.io/emacs/25.1/Directory-Variables.html
** 現在カーソルの単語を得る(things-at-point)
