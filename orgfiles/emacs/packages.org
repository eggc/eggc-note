* built-in package
** xref

https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/xref.el

定義ジャンプなどの機能を提供する。

** vc-git

https://github.com/emacs-mirror/emacs/blob/master/lisp/vc/vc-git.el

バージョン管理に関係した機能を提供する。
git grep による検索 M-x vc-git-grep が定義されている。

** list-packages

M-x list-packages でパッケージ一覧を表示する。

| キー | 効果                   |
|------+------------------------|
| /n   | パッケージ名でフィルタ |
| //   | フィルタを解除         |

* use-package

https://github.com/jwiegley/use-package

マクロにより設定を短く書ける。

* dumb-jump

https://github.com/jacktasia/dumb-jump

* ivy, counsel

https://github.com/abo-abo/swiper

補完インターフェース

M-x の呼び出し時に ^ が自動でつくのだがこれがいらない。

#+begin_src lisp
(ivy-configure 'counsel-M-x
  :initial-input "^"
  :display-transformer-fn #'counsel-M-x-transformer)
#+end_src

自分で使いたい場合は次のようにする。

#+begin_src lisp
(ivy-read "選んでください：" '(みかん りんご なすび))
#+end_src

** ivy-xref

https://github.com/alexmurray/ivy-xref

xref の検索結果を ivy インターフェースで選択するプラグイン。

* projectile

git grep を有効にしておかないと mac の BSD grep が使用されて検索が遅い。
git grep にしておけば十分早い。

#+begin_src lisp
(setq projectile-use-git-grep t)
#+end_src

s-p を projectile-command-map にアサインした前提。

| キー    | 効果     |
|---------+----------|
| s-p s g | 全文検索 |
* typescript-mode

https://github.com/emacs-typescript/typescript.el

https://github.com/ananthakumaran/tide/#typescript に書いてあるとおりやる

自動的にフォーマットするやつは変形させれる

#+begin_src lisp
(setq tide-format-options
  '(
  :insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis nil
  :insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets nil
  :insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces nil
  ))
#+end_src

これは eslint とは別の機能らしい。

#+begin_src lisp
{
  "indentSize": 4,
  "tabSize": 4,
  "insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": false,
  "placeOpenBraceOnNewLineForFunctions": false,
  "placeOpenBraceOnNewLineForControlBlocks": false
}
#+end_src

* magit

** 他のブランチのファイルを見る

M-x magit-find-file

** ediff

git merge release がコンフリクトしたとする。
ここで ediff によるコンフリクト解消を試みる。

M-x magit-ediff-resolve

Resolve file: <FILE_NAME>

たとえば <FILE_NAME> が core.rb だとすると下記の 4 つのウィンドウが表示される

- [A] core.rb UPPER=HEAD... 略
- [B] core.rb LOWER=release ... 略
- [diff(A+B)] ediff-merge
- ミニバッファ

ミニバッファをアクティブにした状態で下記の操作ができる。
逆に言うとミニバッファにカーソルがあたってないと操作できない。

| キー | 操作                  |
|------+-----------------------|
| n/p  | 次/前のhunkに移動する |
| v/V  | 下に/上にスクロール   |
| a    | [A] を採用            |
| b    | [B] を採用            |
| r    | [diff(A+B)] に戻す    |
| *    | 手で直す              |
| q    | 終了                  |
| h    | ハイライト消す/つける |
|      |                       |

ediff-merge を直接編集したりすると面倒になるので注意。

* flycheck

動的な(on-the-fly)シンタックスチェッカー

| 操作    | 意味                                                 |
|---------+------------------------------------------------------|
| M-n     | (flycheck-next-error) 直後のエラー箇所にジャンプ     |
| M-p     | (flycheck-previous-error) 直前のエラー箇所にジャンプ |
| C-c ! l | エラーのリストを表示                                 |

* emacs-tree-sitter

** 正規表現によるシンタックスハイライトの問題

Emacs のいくつかのモードでは、ソースコードの色付けを正規表現によって実現してきた。たとえば ruby-mode のソースコードを見ると[[https://github.com/emacs-mirror/emacs/blob/698e044a253e9d0e4ec2c74b0b9648f139f2192b/lisp/progmodes/ruby-mode.el#L42-L135][このような大量の正規表現]]を使っている。しかし、正規表現は文脈を持たないのに対して、ソースコードは文脈を持つため正しく色付けできないソースコードも存在する。たとえば、[[https://qiita.com/eggc/items/718dd41fa778b91f302e][二重の式展開を ruby-mode は正しく解釈できない]]。

他の例としては tsx のサポートも問題の一つと言える。Emacs で Typescript を利用するためのモード typescript-mode は開発されているが tsx は[[https://github.com/emacs-typescript/typescript.el/issues/4][今でもサポートされていない]]。[[https://qiita.com/nuy/items/ebcb25ad14f02ab72790][この記事]]のようにモードを組み合わせて妥協点を探すしかないが、安定性やパフォーマンス面に問題があり、十分なものとは言えなかった。

** LSP によるセマンティックハイライト

正規表現によるシンタックスハイライトに対して、ソースコードを意味的に解釈して色付けを行う方法をセマンティックハイライトと呼ぶ。Eclipse のような IDE では古くからセマンティックハイライトを使ってソースコードを色付けしていたらしい。セマンティックハイライトは文脈を解釈するので正規表現によるハイライトよりも精密な色付けが可能である。

Visual Studio Code も Emacs と同じように正規表現によるシンタックスハイライトを行っていたが、最新のバージョンでは LSP によるセマンティックハイライトに対応したらしい。Language Server とエディタの間でセマンティックトークンと呼ばれる文法情報をやりとりして色付けを決定するようだ。[[https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide][詳細はこの記事]]に書いてある。

Emacs でも LSP によるセマンティックハイライトを使いたいなら lsp-mode をインストールして、オプション ~lsp-enable-semantic-highlighting~ を有効にすれば利用できるらしい。ただし、もうひとつの LSP クライアントである eglot は[[https://github.com/joaotavora/eglot/issues/615][セマンティックハイライトに対応しない方針のようだ]]。理由として、LSPを通じたセマンティックハイライトは、Emacs 組み込みのハイライト font lock よりも低速であると添えている。

試しに Typescript に LSP を通じたセマンティックハイライトを与えてみよう。

** tree-sitter によるセマンティックハイライト
Typescript のように強力な language server が提供されている言語であれば LSP によるセマンティックハイライトは有効に働くと思うが、すべての言語で LSP をセットアップ済みとは限らない。

Emacs でも tree-sitter を使えばセマンティックハイライトを実現できる。

[[https://tree-sitter.github.io/tree-sitter/][tree-sitter]] は、2018年頃(?)に生まれたソースコードを解析して高速に構文木を作成するライブラリ。一度作成した構文木は保持していて、ソースコードの変更に追従して内部的な構文木を変化させることができるらしい。ほとんどのメジャーなプログラミング言語に対応している。



ソースコードを解析するという点においては tree-sitter と LSP は似ているが、LSP は最小限の機能しか持っていないのに対して LSP はコード補完やドキュメント参照など幅広い機能を定めている。最新の LSP では [[https://microsoft.github.io/language-server-protocol/specification#textDocument_colorPresentation][Color Presentation Request]] という機能がサポートされている。

これを使うことができるなら tree-sitter を追加する必要はないかもしれない。Visual Studio Code では [[https://marketplace.visualstudio.com/items?itemName=georgewfraser.vscode-tree-sitter][tree-sitter に対応させるパッケージ]]が公開されているが、非推奨となっている。

しかし Emacs での LSP のサポートは完全ではなくてソースコードの色付けには未だに正規表現に頼っているところがある。なので完全に LSP に対応するまでは tree-sitter と LSP を併用するのもありなのでは、と思う。もちろん、そうする場合は構文木をそれぞれが作成するためオーバーヘッドが生じる。ただ、普段遣いだと気にならないくらいに高速に動いてるように見える。

さて、tree-sitter は、実行ファイルなどは提供してなくて純粋なC言語のライブラリとして提供されている。一応 rust や nodejs からアクセスするためのインターフェースもある。上記の通り C 言語のライブラリなので素直に Emacs から呼び出すことができない。そこで dynamic module という機能を使って tree-sitter を呼び出さなければならない。dynamic module については[[https://qiita.com/trueroad/items/b87f0dffb658b328831c][この記事]]が詳しい。

dynamic module を使った tree-sitter の呼び出し実装が [[https://emacs-tree-sitter.github.io/][emacs-tree-sitter]] である。emacs-tree-sitter の[[https://emacs-tree-sitter.github.io/getting-started/][導入ページ]]に書いてあるデフォルト設定 ~(global-tree-sitter-mode)~ では、jsx や tsx がうまく解釈できないことに注意。原因は、Emacs メジャーモードと tree-sitter パーサーでできたリスト変数の初期値に jsx と tsx が含まれていないため。このことは
